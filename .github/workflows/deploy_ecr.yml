name: Deploy to Production

on:
  workflow_dispatch:
  push:
    branches:
      - master

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_ACCESS_KEY: ${{ vars.AWS_ACCESS_KEY }}
  APP_NAME: ${{ vars.APP_NAME }}
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_BUCKET: ${{ vars.AWS_BUCKET }}
  DB_PROVIDER: ${{ vars.DB_PROVIDER }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  DB_USER: ${{ vars.DB_USER }}
  DB_HOST: ${{ vars.DB_HOST }}
  DB_NAME: ${{ vars.DB_NAME }}
  POSTMARK_API_KEY: ${{ secrets.POSTMARK_API_KEY }}
  SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
  TOKEN_SECRET: ${{ secrets.TOKEN_SECRET }}
  CRYPTO_SECRET: ${{ secrets.CRYPTO_SECRET }}
  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_KEY }}
  REDIS_PASS: ${{ secrets.REDIS_PASS }}
  ECR_URI: ${{ vars.ECR_URI }} # 236992227954.dkr.ecr.us-east-1.amazonaws.com/<project>/<folder>:version
  SERVER_DNS: ${{ vars.SERVER_DNS }} # ec2-XX-XXX-XXX-XX.compute-1.amazonaws.com

jobs:
  # NOTE:
  # Verify if mandatory environment variables are properly set, by checking it's
  # existence.
  # If there's any fail, proceed on blocking the CI run.
  verify-env-vars:
    name: Verify Environment Variables
    runs-on: ubuntu-latest

    steps:
      - name: Check Required Environment Variables
        continue-on-error: true
        run: |
          REQUIRED_VARS=(
            AWS_ACCESS_KEY APP_NAME AWS_REGION AWS_BUCKET DB_PROVIDER 
            AWS_SECRET_ACCESS_KEY DB_PASSWORD DB_USER DB_HOST DB_NAME 
            POSTMARK_API_KEY SESSION_SECRET TOKEN_SECRET CRYPTO_SECRET 
            SSH_PRIVATE_KEY ECR_URI SERVER_DNS
          )

          missing_vars=()

          for var in "${REQUIRED_VARS[@]}"; do
            if [ -z "${!var}" ]; then
              missing_vars+=("$var")
            fi
          done

          if [ ${#missing_vars[@]} -ne 0 ]; then
            echo "❌ Missing required environment variables: ${missing_vars[*]}"
            exit 1
          else
            echo "✅ All required environment variables are set."
          fi

  build:
    name: Docker Production Build
    runs-on: ubuntu-latest
    needs: verify-env-vars
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    if: |
      success() && (
        github.event_name == 'push' || 
        github.event_name == 'workflow_dispatch' ||
        (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'deploy'))
      )

    steps:
      - uses: actions/checkout@v3

      - name: Verify Scoped Environment Variables
        run: |
          if [ -z "${{ vars.PORT }}" ] || [ -z "${{ vars.NODE_ENV }}" ]; then
            echo "❌ Missing required environment variables: PORT or NODE_ENV"
            exit 1
          else
            echo "✅ Scoped environment variables are set: PORT=${{ vars.PORT }}, NODE_ENV=${{ vars.NODE_ENV }}"
          fi

      - name: Log in to Amazon ECR
        run: |
          echo "Logging in to Amazon ECR..."

          aws configure set aws_access_key_id ${{ vars.AWS_ACCESS_KEY }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set region ${{ vars.AWS_REGION }}
          aws configure set output "json"

          aws ecr get-login-password --region ${{ vars.AWS_REGION }} | docker login --username AWS --password-stdin ${{ vars.ECR_URI }}

      - name: Build Docker Images
        env:
          PORT: ${{ vars.PORT }}
          NODE_ENV: ${{ vars.NODE_ENV }}
        run: |
          docker compose -f compose.yml \
            -f compose/deploy.yml \
            build

      - name: Extract version from Git tag
        if: startsWith(github.ref, 'refs/tags/')
        run: echo "VERSION=${GITHUB_REF_NAME}" >> $GITHUB_ENV

      - name: Tag Docker Images
        run: |
          docker tag app-server:latest ${{ vars.ECR_URI }}:main_server_${{ vars.NODE_ENV }}_latest
          docker tag app-server:latest ${{ vars.ECR_URI }}:main_server_${{ vars.NODE_ENV }}_${VERSION}
          docker tag admin-server:latest ${{ vars.ECR_URI }}:admin_server_${{ vars.NODE_ENV }}_latest
          docker tag admin-server:latest ${{ vars.ECR_URI }}:admin_server_${{ vars.NODE_ENV }}_${VERSION}

      - name: Push Docker Images to Registry
        run: |
          docker push ${{ vars.ECR_URI }}:main_server_${{ vars.NODE_ENV }}_latest
          docker push ${{ vars.ECR_URI }}:main_server_${{ vars.NODE_ENV }}_${VERSION}
          docker push ${{ vars.ECR_URI }}:admin_server_${{ vars.NODE_ENV }}_latest
          docker push ${{ vars.ECR_URI }}:admin_server_${{ vars.NODE_ENV }}_${VERSION}

  deploy:
    name: Docker Production Build
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    if: |
      success() && (
        github.event_name == 'push' || 
        github.event_name == 'workflow_dispatch' ||
        (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'deploy'))
      )

    steps:
      - name: Deploy to Production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ vars.SERVER_DNS }} >> ~/.ssh/known_hosts
          ssh ubuntu@${{ vars.SERVER_DNS }} << 'EOF'
            docker stop main_server_${{ vars.NODE_ENV }} || true && main_server_${{ vars.NODE_ENV }} || true
            docker stop admin_server_${{ vars.NODE_ENV }} || true && admin_server_${{ vars.NODE_ENV }} || true

            docker system prune -af

            docker network create app || true

            aws configure set aws_access_key_id ${{ vars.AWS_ACCESS_KEY }}
            aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws configure set region ${{ vars.AWS_REGION }}
            aws configure set output "json"

            aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ vars.ECR_URI }}

            docker pull ${{ vars.ECR_URI }}:main_server_${{ vars.NODE_ENV }}_latest
            docker pull ${{ vars.ECR_URI }}:admin_server_${{ vars.NODE_ENV }}_latest

            cat > /home/ubuntu/.env <<EOF
            PORT=${{ vars.PORT }}
            NODE_ENV=${{ vars.NODE_ENV }}
            DB_HOST=${{ vars.DB_HOST }}
            DB_USER=${{ vars.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_NAME=${{ vars.DB_NAME }}
            SESSION_SECRET=${{ secrets.SESSION_SECRET }}
            TOKEN_SECRET=${{ secrets.TOKEN_SECRET }}
            CRYPTO_SECRET=${{ secrets.CRYPTO_SECRET }}
            SUPPORT_EMAIL=${{ secrets.SUPPORT_EMAIL }}
            POSTMARK_API_KEY=${{ secrets.POSTMARK_API_KEY }}
            REDIS_PASS=${{ secrets.REDIS_PASS }}
            EOF

            docker run -d \
              --name main_server_${{ vars.NODE_ENV }} \
              --restart always \
              -p ${{ vars.PORT }}:${{ vars.PORT }} \
              --env-file /home/ubuntu/.env \
              --label logging=promtail \
              --label logging_jobname="${{ vars.APP_NAME }}_main_server_${{ vars.NODE_ENV }}" \
              --network app \
              ${{ vars.ECR_URI }}:main_server_${{ vars.NODE_ENV }}_latest

            docker run -d \
              --name admin_server_${{ vars.NODE_ENV }} \
              -p 5001:5001 \
              --env-file /home/ubuntu/.env \
              --restart always \
              --label logging=promtail \
              --label logging_jobname="${{ vars.APP_NAME }}_admin_server_${{ vars.NODE_ENV }}" \
              --network app \
              ${{ vars.ECR_URI }}:admin_server_${{ vars.NODE_ENV }}_latest
          EOF

  post-deploy:
    name: Docker Production Build
    runs-on: ubuntu-latest
    needs: deploy
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    if: |
      success() && (
        github.event_name == 'push' || 
        github.event_name == 'workflow_dispatch' ||
        (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'deploy'))
      )

    steps:
      - name: Remove 'deploy' label
        if: always()
        run: |
          curl -X DELETE \
          -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/labels/deploy
